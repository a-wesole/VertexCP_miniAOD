// -*- C++ -*-
//
// Package:    VertexCompositeProducer
// Class:      D0Fitter
//
/**\class D0Fitter D0Fitter.cc VertexCompositeAnalysis/VertexCompositeProducer/src/D0Fitter.cc

 Description: <one line class summary>

 Implementation:
     <Notes on implementation>
*/
//
//
//

#include "VertexCompositeAnalysis/VertexCompositeProducer/interface/D0Fitter.h"
#include "CommonTools/CandUtils/interface/AddFourMomenta.h"

#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
#include "TrackingTools/Records/interface/TransientTrackRecord.h"
#include "TrackingTools/PatternTools/interface/ClosestApproachInRPhi.h"
#include "TrackingTools/PatternTools/interface/TwoTrackMinimumDistance.h"

#include "DataFormats/PatCandidates/interface/PackedCandidate.h"
#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/PatCandidates/interface/GenericParticle.h"

#include "Geometry/CommonDetUnit/interface/GlobalTrackingGeometry.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "TrackingTools/TrajectoryState/interface/TrajectoryStateTransform.h"
#include "TrackingTools/PatternTools/interface/TSCBLBuilderNoMaterial.h"

#include "RecoVertex/KinematicFitPrimitives/interface/MultiTrackKinematicConstraint.h"
#include "RecoVertex/KinematicFit/interface/KinematicConstrainedVertexFitter.h"
#include "RecoVertex/KinematicFit/interface/TwoTrackMassKinematicConstraint.h"
#include "RecoVertex/KalmanVertexFit/interface/KalmanVertexFitter.h"

#include "DataFormats/BeamSpot/interface/BeamSpot.h"

#include <Math/Functions.h>
#include <Math/SVector.h>
#include <Math/SMatrix.h>
#include <TMath.h>
#include <TVector3.h>
#include "TrackingTools/IPTools/interface/IPTools.h"
#include "CommonTools/Statistics/interface/ChiSquaredProbability.h"
#include "TLorentzVector.h"

const float piMassD0 = 0.13957018;
const float piMassD0Squared = piMassD0 * piMassD0;
const float kaonMassD0 = 0.493677;
const float kaonMassD0Squared = kaonMassD0 * kaonMassD0;
const float d0MassD0 = 1.86484;
float piMassD0_sigma = 3.5E-7f;
float kaonMassD0_sigma = 1.6E-5f;

// Constructor and (empty) destructor
D0Fitter::D0Fitter(const edm::ParameterSet &theParameters, edm::ConsumesCollector &&iC) : bField_esToken_(iC.esConsumes<MagneticField, IdealMagneticFieldRecord>())
{
  using std::string;

  // Get the track reco algorithm from the ParameterSet
  token_beamSpot = iC.consumes<reco::BeamSpot>(edm::InputTag("offlineBeamSpot"));
  // token_tracks = iC.consumes<reco::TrackCollection>(theParameters.getParameter<edm::InputTag>("trackRecoAlgorithm"));
  token_tracks_pf = iC.consumes<std::vector<pat::PackedCandidate>>(theParameters.getParameter<edm::InputTag>("trackRecoAlgorithm"));
  token_vertices = iC.consumes<reco::VertexCollection>(theParameters.getParameter<edm::InputTag>("vertexRecoAlgorithm"));
  token_dedx = iC.consumes<edm::ValueMap<reco::DeDxData>>(edm::InputTag("dedxHarmonic2"));

  // Second, initialize post-fit cuts
  mPiKCutMin = theParameters.getParameter<double>(string("mPiKCutMin"));
  mPiKCutMax = theParameters.getParameter<double>(string("mPiKCutMax"));
  tkDCACut = theParameters.getParameter<double>(string("tkDCACut"));
  tkChi2Cut = theParameters.getParameter<double>(string("tkChi2Cut"));
  tkNhitsCut = theParameters.getParameter<int>(string("tkNhitsCut"));
  tkPtCut = theParameters.getParameter<double>(string("tkPtCut"));
  tkPtErrCut = theParameters.getParameter<double>(string("tkPtErrCut"));
  tkEtaCut = theParameters.getParameter<double>(string("tkEtaCut"));
  tkPtSumCut = theParameters.getParameter<double>(string("tkPtSumCut"));
  tkEtaDiffCut = theParameters.getParameter<double>(string("tkEtaDiffCut"));
  chi2Cut = theParameters.getParameter<double>(string("vtxChi2Cut"));
  rVtxCut = theParameters.getParameter<double>(string("rVtxCut"));
  rVtxSigCut = theParameters.getParameter<double>(string("vtxSignificance2DCut"));
  lVtxCut = theParameters.getParameter<double>(string("lVtxCut"));
  lVtxSigCut = theParameters.getParameter<double>(string("vtxSignificance3DCut"));
  collinCut2D = theParameters.getParameter<double>(string("collinearityCut2D"));
  collinCut3D = theParameters.getParameter<double>(string("collinearityCut3D"));
  d0MassCut = theParameters.getParameter<double>(string("d0MassCut"));
  dauTransImpactSigCut = theParameters.getParameter<double>(string("dauTransImpactSigCut"));
  dauLongImpactSigCut = theParameters.getParameter<double>(string("dauLongImpactSigCut"));
  VtxChiProbCut = theParameters.getParameter<double>(string("VtxChiProbCut"));
  dPtCut = theParameters.getParameter<double>(string("dPtCut"));
  alphaCut = theParameters.getParameter<double>(string("alphaCut"));
  alpha2DCut = theParameters.getParameter<double>(string("alpha2DCut"));
  isWrongSign = theParameters.getParameter<bool>(string("isWrongSign"));

  // what to do about this?? abby
  //   std::vector<std::string> qual = theParameters.getParameter<std::vector<std::string>>("trackQualities");
  //   for (unsigned int ndx = 0; ndx < qual.size(); ndx++)
  //   {
  //     qualities.push_back(reco::TrackBase::qualityByName(qual[ndx]));
  //   }
}

D0Fitter::~D0Fitter()
{
  // not sure if need abby
  // delete forest_;
}

// Method containing the algorithm for vertex reconstruction
void D0Fitter::fitAll(const edm::Event &iEvent, const edm::EventSetup &iSetup)
{

  using std::cout;
  using std::endl;
  using std::vector;
  using namespace reco;
  using namespace edm;
  using namespace std;

  // std::cout << "[fitAll] Starting fitAll()" << std::endl;

  typedef ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3>> SMatrixSym3D;
  typedef ROOT::Math::SVector<double, 3> SVector3;

  Handle<pat::PackedCandidateCollection> packedHandle;
  Handle<VertexCollection> theVertexHandle;
  Handle<reco::BeamSpot> theBeamSpotHandle;

  ESHandle<MagneticField> bFieldHandle;
  Handle<edm::ValueMap<reco::DeDxData>> dEdxHandle;

  // Get the tracks, vertices from the event, and get the B-field record
  //  from the EventSetup
  // abby
  // iEvent.getByToken(token_tracks, theTrackHandle);
  iEvent.getByToken(token_tracks_pf, packedHandle);
  iEvent.getByToken(token_vertices, theVertexHandle);
  iEvent.getByToken(token_beamSpot, theBeamSpotHandle);
  iEvent.getByToken(token_dedx, dEdxHandle);

  // if (!theTrackHandle->size())
  if (!packedHandle.isValid() || packedHandle->empty())
    return;

  // magnetic field needec for other things
  bFieldHandle = iSetup.getHandle(bField_esToken_);
  magField = bFieldHandle.product();

  bool isVtxPV = 0;
  double xVtx = -99999.0;
  double yVtx = -99999.0;
  double zVtx = -99999.0;
  // double xVtxError = -999.0;
  // double yVtxError = -999.0;
  // double zVtxError = -999.0;
  const reco::VertexCollection vtxCollection = *(theVertexHandle.product());

  //  cout << " [checkpoint 1] -- Success found vertex collection with size " << vtxCollection.size() << endl;

  reco::VertexCollection::const_iterator vtxPrimary = vtxCollection.begin();
  if (vtxCollection.size() > 0 && !vtxPrimary->isFake() && vtxPrimary->tracksSize() >= 2)
  {
    isVtxPV = 1;
    xVtx = vtxPrimary->x();
    yVtx = vtxPrimary->y();
    zVtx = vtxPrimary->z();
    // xVtxError = vtxPrimary->xError();
    // yVtxError = vtxPrimary->yError();
    // zVtxError = vtxPrimary->zError();
  }
  else
  {
    isVtxPV = 0;
    xVtx = theBeamSpotHandle->position().x();
    yVtx = theBeamSpotHandle->position().y();
    zVtx = 0.0;
    // xVtxError = theBeamSpotHandle->BeamWidthX();
    // yVtxError = theBeamSpotHandle->BeamWidthY();
    // zVtxError = 0.0;
  }
  math::XYZPoint bestvtx(xVtx, yVtx, zVtx);

  // abby - updated for pfcandidiates
  // Loop over PackedCandidates and apply preselection cuts to identify good D0 daughter tracks
  std::vector<pat::PackedCandidate> input_daughter_tracks;
  // --note input_daughter_tracks = daughter tracks

  for (size_t i = 0; i < packedHandle->size(); ++i) //for all tracks
  {
    const auto &cand = (*packedHandle)[i]; //get track

    // Make sure the candidate is charged and has tracking information
    if (cand.charge() == 0 || !cand.hasTrackDetails())
      continue;

    // Basic kinematic cuts
    if (cand.pt() < tkPtCut || fabs(cand.eta()) > tkEtaCut)
      continue;

    // Optional quality proxies via pseudoTrack and bestTrack
    if (cand.pseudoTrack().normalizedChi2() >= tkChi2Cut ||
        cand.pseudoTrack().numberOfValidHits() < tkNhitsCut ||
        (cand.bestTrack() &&
         (cand.bestTrack()->ptError() / cand.pt()) >= tkPtErrCut))
      continue;

    // Impact parameter significance cuts
    double dzvtx = cand.dz(vtxPrimary->position());
    double dxyvtx = cand.dxy(vtxPrimary->position());
    double dzerror = std::sqrt(std::pow(cand.dzError(), 2) + std::pow(vtxPrimary->zError(), 2));
    double dxyerror = std::sqrt(std::pow(cand.dxyError(), 2) +
                                std::pow(vtxPrimary->xError(), 2) * std::pow(vtxPrimary->yError(), 2));

    double dauLongImpactSig = dzvtx / dzerror;
    double dauTransImpactSig = dxyvtx / dxyerror;

    if (fabs(dauLongImpactSig) < dauLongImpactSigCut ||
        fabs(dauTransImpactSig) < dauTransImpactSigCut)
      continue;

    input_daughter_tracks.push_back(cand);
  }
   //filters out some of the not so good tracks 

  // now loop over all input daughter tracks and do the fitting let's see
  // first some useful arrays

  float posCandMass[2] = {piMassD0, kaonMassD0};
  float negCandMass[2] = {kaonMassD0, piMassD0};
  float posCandMass_sigma[2] = {piMassD0_sigma, kaonMassD0_sigma};
  float negCandMass_sigma[2] = {kaonMassD0_sigma, piMassD0_sigma};
  int pdg_id[2] = {421, -421};

  //loop over all th egood tracks,2 at a time to see if they are d0 canididates
  cout << " [checkpoint 2] -- Starting track pair loop with " << input_daughter_tracks.size() << " tracks." << endl;
  for (unsigned int trdx1 = 0; trdx1 < input_daughter_tracks.size(); trdx1++)
  {

    for (unsigned int trdx2 = trdx1 + 1; trdx2 < input_daughter_tracks.size(); trdx2++)
    {
      const auto &tk1 = input_daughter_tracks[trdx1];
      const auto &tk2 = input_daughter_tracks[trdx2];

      if (tk1.pt() + tk2.pt() < tkPtSumCut)
        continue;
      if (fabs(tk1.eta() - tk2.eta()) > tkEtaDiffCut)
        continue;


      int q1 = tk1.charge();
      int q2 = tk2.charge();

      if (!isWrongSign && q1 * q2 != -1)
        continue;
      if (isWrongSign && q1 * q2 != 1)
        continue;


      reco::TransientTrack tt1(tk1.pseudoTrack(), magField);
      reco::TransientTrack tt2(tk2.pseudoTrack(), magField);

      if (!tt1.impactPointTSCP().isValid() || !tt2.impactPointTSCP().isValid())
        continue;

      // DCA calculation
      FreeTrajectoryState state1 = tt1.impactPointTSCP().theState();
      FreeTrajectoryState state2 = tt2.impactPointTSCP().theState();

      ClosestApproachInRPhi cApp;
      cApp.calculate(state1, state2);
      if (!cApp.status())
        continue;

      float dca = fabs(cApp.distance());
      GlobalPoint cxPt = cApp.crossingPoint();
      if (dca < 0. || dca > tkDCACut)
        continue;

      // abby -- up to here is updated loooooooooooooooooooooooooook

      if (sqrt(cxPt.x() * cxPt.x() + cxPt.y() * cxPt.y()) > 120. || std::abs(cxPt.z()) > 300.)
        continue;

      // cout << "cut 6" << endl;

      // Assign mass hypotheses for the two combinations: [K-, π+] and [π-, K+]

      TLorentzVector p4_kaon, p4_pion;

      if (!isWrongSign && q1 < 0 && q2 > 0)
      {
        p4_kaon.SetPtEtaPhiM(tk1.pt(), tk1.eta(), tk1.phi(), kaonMassD0); // tk1 = K-
        p4_pion.SetPtEtaPhiM(tk2.pt(), tk2.eta(), tk2.phi(), piMassD0);   // tk2 = π+
      }
      else if (!isWrongSign && q1 > 0 && q2 < 0)
      {
        p4_kaon.SetPtEtaPhiM(tk2.pt(), tk2.eta(), tk2.phi(), kaonMassD0); // tk2 = K+
        p4_pion.SetPtEtaPhiM(tk1.pt(), tk1.eta(), tk1.phi(), piMassD0);   // tk1 = π-
      }

      TLorentzVector sum = p4_kaon + p4_pion;
      double mass = sum.M();

      auto ts1 = tt1.trajectoryStateClosestToPoint(cxPt);
      auto ts2 = tt2.trajectoryStateClosestToPoint(cxPt);

      double totalE1 = sqrt(ts1.momentum().mag2() + kaonMassD0Squared) +
                       sqrt(ts2.momentum().mag2() + piMassD0Squared);
      double totalE1Sq = totalE1 * totalE1;

      double totalE2 = sqrt(ts1.momentum().mag2() + piMassD0Squared) +
                       sqrt(ts2.momentum().mag2() + kaonMassD0Squared);
      double totalE2Sq = totalE2 * totalE2;

      double totalPSq =
          (ts1.momentum() + ts2.momentum()).mag2();

      auto sumMom = (ts1.momentum() + ts2.momentum());
      double totalPt = sumMom.perp();

      double mass1 = sqrt(totalE1Sq - totalPSq);
      double mass2 = sqrt(totalE2Sq - totalPSq);

      if ((mass1 > mPiKCutMax || mass1 < mPiKCutMin) && (mass2 > mPiKCutMax || mass2 < mPiKCutMin))
        continue;


      /*
      if ((mass1 < mPiKCutMin || mass1 > mPiKCutMax) &&
          (mass2 < mPiKCutMin || mass2 > mPiKCutMax))
        continue;
      */

      cout << "cut 7a -- need to come abck and fix this " << endl;
      if (totalPt < dPtCut)
        continue;
      // the above keeps the pairs that align with k mass and pi mass and assigned pid

      // Create the vertex fitter object and vertex the tracks

      float posCandTotalE[2] = {0.0};
      float negCandTotalE[2] = {0.0};
      float d0TotalE[2] = {0.0};

      // create TransientTracks from the packedcandidates, need them for the kinematic fit
      reco::TransientTrack posTT(tk1.pseudoTrack(), magField);
      reco::TransientTrack negTT(tk2.pseudoTrack(), magField);

      // Creating a KinematicParticleFactory
      KinematicParticleFactoryFromTransientTrack pFactory;
      float chi = 0.0;
      float ndf = 0.0;

      // loop over the two hypotheses, k-. pi+ and pi- k+
      for (int i = 0; i < 2; i++)
      {
        std::vector<RefCountedKinematicParticle> d0Particles;

        float massPos = posCandMass[i];
        float massNeg = negCandMass[i];
        float sigmaPos = posCandMass_sigma[i];
        float sigmaNeg = negCandMass_sigma[i];

        d0Particles.push_back(pFactory.particle(posTT, posCandMass[i], chi, ndf, posCandMass_sigma[i]));
        d0Particles.push_back(pFactory.particle(negTT, negCandMass[i], chi, ndf, negCandMass_sigma[i]));

        KinematicParticleVertexFitter d0Fitter;
        RefCountedKinematicTree d0Vertex;
        d0Vertex = d0Fitter.fit(d0Particles);

        if (!d0Vertex->isValid())
          continue;

        d0Vertex->movePointerToTheTop();
        RefCountedKinematicParticle d0Cand = d0Vertex->currentParticle();
        if (!d0Cand->currentState().isValid())
          continue;

        RefCountedKinematicVertex d0DecayVertex = d0Vertex->currentDecayVertex();
        if (!d0DecayVertex->vertexIsValid())
          continue;

        float d0C2Prob = TMath::Prob(d0DecayVertex->chiSquared(), d0DecayVertex->degreesOfFreedom());
        if (d0C2Prob < VtxChiProbCut)
          continue;

        d0Vertex->movePointerToTheFirstChild();
        RefCountedKinematicParticle posCand = d0Vertex->currentParticle();
        d0Vertex->movePointerToTheNextChild();
        RefCountedKinematicParticle negCand = d0Vertex->currentParticle();

        if (!posCand->currentState().isValid() || !negCand->currentState().isValid())
          continue;

        // cout << "cut 8" << endl;
        KinematicParameters posCandKP = posCand->currentState().kinematicParameters();
        KinematicParameters negCandKP = negCand->currentState().kinematicParameters();
        // Grab basic objects
        

        GlobalVector d0TotalP = GlobalVector(d0Cand->currentState().globalMomentum().x(),
                                             d0Cand->currentState().globalMomentum().y(),
                                             d0Cand->currentState().globalMomentum().z());

        GlobalVector posCandTotalP = GlobalVector(posCandKP.momentum().x(), posCandKP.momentum().y(), posCandKP.momentum().z());
        GlobalVector negCandTotalP = GlobalVector(negCandKP.momentum().x(), negCandKP.momentum().y(), negCandKP.momentum().z());

        posCandTotalE[i] = sqrt(posCandTotalP.mag2() + posCandMass[i] * posCandMass[i]);
        negCandTotalE[i] = sqrt(negCandTotalP.mag2() + negCandMass[i] * negCandMass[i]);
        d0TotalE[i] = posCandTotalE[i] + negCandTotalE[i];

        const Particle::LorentzVector d0P4(d0TotalP.x(), d0TotalP.y(), d0TotalP.z(), d0TotalE[i]);

        Particle::Point d0Vtx((*d0DecayVertex).position().x(), (*d0DecayVertex).position().y(), (*d0DecayVertex).position().z());

        std::vector<double> d0VtxEVec;
        d0VtxEVec.push_back(d0DecayVertex->error().cxx());
        d0VtxEVec.push_back(d0DecayVertex->error().cyx());
        d0VtxEVec.push_back(d0DecayVertex->error().cyy());
        d0VtxEVec.push_back(d0DecayVertex->error().czx());
        d0VtxEVec.push_back(d0DecayVertex->error().czy());
        d0VtxEVec.push_back(d0DecayVertex->error().czz());
        SMatrixSym3D d0VtxCovMatrix(d0VtxEVec.begin(), d0VtxEVec.end());
        const Vertex::CovarianceMatrix d0VtxCov(d0VtxCovMatrix);
        double d0VtxChi2(d0DecayVertex->chiSquared());
        double d0VtxNdof(d0DecayVertex->degreesOfFreedom());
        double d0NormalizedChi2 = d0VtxChi2 / d0VtxNdof;

        double rVtxMag = 99999.0;
        double lVtxMag = 99999.0;
        double sigmaRvtxMag = 999.0;
        double sigmaLvtxMag = 999.0;
        double d0Angle3D = -100.0;
        double d0Angle2D = -100.0;

        GlobalVector d0LineOfFlight = GlobalVector(d0Vtx.x() - xVtx,
                                                   d0Vtx.y() - yVtx,
                                                   d0Vtx.z() - zVtx);

        SMatrixSym3D d0TotalCov;
        if (isVtxPV)
          d0TotalCov = d0VtxCovMatrix + vtxPrimary->covariance();
        else
          d0TotalCov = d0VtxCovMatrix + theBeamSpotHandle->rotatedCovariance3D();

        SVector3 distanceVector3D(d0LineOfFlight.x(), d0LineOfFlight.y(), d0LineOfFlight.z());
        SVector3 distanceVector2D(d0LineOfFlight.x(), d0LineOfFlight.y(), 0.0);

        d0Angle3D = angle(d0LineOfFlight.x(), d0LineOfFlight.y(), d0LineOfFlight.z(),
                          d0TotalP.x(), d0TotalP.y(), d0TotalP.z());
        d0Angle2D = angle(d0LineOfFlight.x(), d0LineOfFlight.y(), (float)0.0,
                          d0TotalP.x(), d0TotalP.y(), (float)0.0);

        lVtxMag = d0LineOfFlight.mag();
        rVtxMag = d0LineOfFlight.perp();
        sigmaLvtxMag = sqrt(ROOT::Math::Similarity(d0TotalCov, distanceVector3D)) / lVtxMag;
        sigmaRvtxMag = sqrt(ROOT::Math::Similarity(d0TotalCov, distanceVector2D)) / rVtxMag;

        if (d0NormalizedChi2 > chi2Cut ||
            rVtxMag < rVtxCut ||
            rVtxMag / sigmaRvtxMag < rVtxSigCut ||
            lVtxMag < lVtxCut ||
            lVtxMag / sigmaLvtxMag < lVtxSigCut ||
            cos(d0Angle3D) < collinCut3D || cos(d0Angle2D) < collinCut2D || d0Angle3D > alphaCut || d0Angle2D > alpha2DCut)
          continue;
        

         GlobalPoint decayPos = d0DecayVertex->position();

        // // 3D & 2D pointing angles
        // double cosAlpha3D = flightVec.unit().dot(p4.unit());
        // double cosAlpha2D = GlobalVector(flightVec.x(), flightVec.y(), 0).unit().dot(GlobalVector(p4.x(), p4.y(), 0).unit());

        // // Decay lengths
        // double l3D = flightVec.mag();
        // double l2D = flightVec.perp();

        // // Vertex covariance & total covariance
        // SMatrixSym3D vtxCov = d0DecayVertex->error().matrix();
        // SMatrixSym3D refCov = isVtxPV
        //                           ? vtxPrimary->covariance()
        //                           : theBeamSpotHandle->rotatedCovariance3D();
        // SMatrixSym3D totalCov = vtxCov + refCov;

        // // Uncertainties on L3D and L2D
        // SVector3 v3(flightVec.x(), flightVec.y(), flightVec.z());
        // SVector3 v2(flightVec.x(), flightVec.y(), 0.);
        // double sig3D = sqrt(ROOT::Math::Similarity(totalCov, v3)) / l3D;
        // double sig2D = sqrt(ROOT::Math::Similarity(totalCov, v2)) / l2D;

        // // Quality cuts
        // if (d0C2Prob < VtxChiProbCut)
        //   continue;
        // if (l3D < lVtxCut)
        //   continue;
        // if (l3D / sig3D < lVtxSigCut)
        //   continue;
        // if (l2D < rVtxCut)
        //   continue;
        // if (l2D / sig2D < rVtxSigCut)
        //   continue;
        // if (cosAlpha3D < cos(alphaCut))
        //   continue;
        // if (cosAlpha2D < cos(alpha2DCut))
        //   continue;
        // // cout << "cut 9" << endl;

        // // 3D IP wrt PV
        AnalyticalImpactPointExtrapolator extrap(magField);
        TrajectoryStateOnSurface tsos =
            extrap.extrapolate(d0Cand->currentState().freeTrajectoryState(),
                               RecoVertex::convertPos(vtxPrimary->position()));
        if (!tsos.isValid())
          continue;

        // cout << "cut 10" << endl;
        Measurement1D cur3DIP;
        VertexDistance3D a3d;
        GlobalPoint refPoint = tsos.globalPosition();
        GlobalError refPointErr = tsos.cartesianError().position();
        GlobalPoint vertexPosition = RecoVertex::convertPos(vtxPrimary->position());
        GlobalError vertexPositionErr = RecoVertex::convertError(vtxPrimary->error());
        cur3DIP = (a3d.distance(VertexState(vertexPosition, vertexPositionErr), VertexState(refPoint, refPointErr)));
        // Two trkDCA
      /*
		    TwoTrackMinimumDistance minDistCalculator;
		    minDistCalculator.calculate(posState, negState);
		    dca = minDistCalculator.distance();
		    cxPt = minDistCalculator.crossingPoint();
		    GlobalError posErr = posState.cartesianError().position();
		    GlobalError negErr = negState.cartesianError().position();
                  double sigma_x2 = posErr.cxx() + negErr.cxx();
        double sigma_y2 = posErr.cyy() + negErr.cyy();
        */

        // double dcaError = sqrt(sigma_x2 * cxPt.x() * cxPt.x() + sigma_y2 * cxPt.y() * cxPt.y()) / dca;

        // Build Lorentz 4-vector (approximate E = √(p² + m₁²) + √(p² + m₂²))
        float mPos = posCandMass[i], mNeg = negCandMass[i];
        cout << "mPos = " << mPos << ", mNeg = " << mNeg << endl;

        // Create CompositeCandidate
        auto theD0 = std::make_unique<pat::CompositeCandidate>();
        theD0->setP4(d0P4);
        theD0->setPdgId(pdg_id[i]);
        theD0->addUserFloat("track3DDCA", dca);
        //theD0->addUserFloat("track3DDCAErr", dcaError);

        // Add the two daughters
        reco::Candidate::LorentzVector tk1P4(
            tk1.px(), tk1.py(), tk1.pz(),
            std::sqrt(tk1.p() * tk1.p() + mPos * mPos));
        reco::Candidate::LorentzVector tk2P4(
            tk2.px(), tk2.py(), tk2.pz(),
            std::sqrt(tk2.p() * tk2.p() + mNeg * mNeg));

        reco::Candidate::Point decayVertexPos(decayPos.x(), decayPos.y(), decayPos.z());

        reco::Candidate::LorentzVector negP4(negCandTotalP.x(), negCandTotalP.y(), negCandTotalP.z(), negCandTotalE[i]);
        reco::Candidate::LorentzVector posP4(posCandTotalP.x(), posCandTotalP.y(), posCandTotalP.z(), posCandTotalE[i]);
        reco::LeafCandidate theNegCand(-1, negP4, decayVertexPos);
        reco::LeafCandidate thePosCand(1, posP4, decayVertexPos);

        //theD0->addDaughter(theNegCand, "theNegCand");
        //theD0->addDaughter(thePosCand, "thePosCand");

	theD0->addDaughter(input_daughter_tracks[trdx1]);
        theD0->addDaughter(input_daughter_tracks[trdx2]);

	/*reco::CandidatePtr ptrPosCand(pfcandHandle, iPos);
	reco::CandidatePtr ptrNegCand(pfcandHandle, iNeg);
	theD0->addUserCand("thePosCand", ptrPosCand);
	theD0->addUserCand("theNegCand", ptrNegCand);
	*/

	// Vertex coordinates & covariance
        theD0->addUserFloat("vtxX", decayPos.x());
        theD0->addUserFloat("vtxY", decayPos.y());
        theD0->addUserFloat("vtxZ", decayPos.z());
        theD0->addUserFloat("vtxChi2", d0DecayVertex->chiSquared());
        theD0->addUserFloat("vtxNdof", d0DecayVertex->degreesOfFreedom());
        
        //cout << " [D0Fitter] - vtxX = " << decayPos.x() << endl;

        for (int ii = 0; ii < 3; ++ii){
          for (int jj = 0; jj < 3; ++jj){
            //theD0->addUserFloat(fmt::format("vertexCovariance_%d_%d", ii, jj), d0VtxCov(ii, jj));
	    std::string name = "vertexCovariance_" + std::to_string(ii) + "_" + std::to_string(jj);
	    theD0->addUserFloat(name, d0VtxCov(ii, jj));
	  }
	}
        //cout << "all that is left is d0 mass" << endl;
        //cout << " [D0Fitter] - theD0->mass() = " << theD0->mass() << endl;
        //cout << " [D0Fitter] - d0MassD0 = " << d0MassD0 << endl;
        if (fabs(theD0->mass() - d0MassD0) < d0MassCut)
        {
          //cout << " [D0Fitter] - found a D0 candidate with mass = " << theD0->mass() << endl;
          //cout << " [D0Fitter] - yayayayayayayayayayayayayayayay" << endl;
          theD0s.push_back(*theD0);
        }

        // --- end of hypo loop  }
      }
    }
  }
}
// Get methods

const pat::CompositeCandidateCollection &D0Fitter::getD0() const
{
  return theD0s;
}

const std::vector<float> &D0Fitter::getMVAVals() const
{
  return mvaVals_;
}

void D0Fitter::resetAll()
{
  theD0s.clear();
  mvaVals_.clear();
}
